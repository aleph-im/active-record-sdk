{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AARS - Aleph Active Record SDK","text":"<p>AARS is a powerful and flexible Python library built on top of the Aleph decentralized storage network, designed to help you build better backends for your decentralized applications. It provides an easy-to-use interface for managing and querying your data, with a focus on performance and versatility.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Asynchronous, high-performance data storage and retrieval</li> <li>Customizable schema with support for different data types</li> <li>Indexing for efficient querying</li> <li>Revision history tracking for records</li> <li>Support for forgetting data (GDPR compliant)</li> <li>Built-in pagination for large result sets</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install AARS using pip:</p> <pre><code>pip install aars\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with AARS, you will need to define your data schema by creating classes that inherit from Record. These classes represent the objects you want to store and query on the Aleph network.</p> <p>Here\u2019s an example of how you can implement a simple social media platform, that we\u2019ll call \u201cChirper\u201d:</p> <p><pre><code>from src.aars import Record, Index, AARS\nfrom typing import List\n\n\nclass User(Record):\n    username: str\n    display_name: str\n    bio: Optional[str]\n\nclass Chirp(Record):\n    author: User\n    content: str\n    likes: int\n    timestamp: int\n</code></pre> In this example, we have a User class representing a user of Chirper, and a Chirp class representing a user\u2019s message. Now, let\u2019s create some indices to make querying our data more efficient:</p> <p><pre><code>Index(User, 'username')\nIndex(Chirp, 'author')\nIndex(Chirp, 'timestamp')\n</code></pre> With the schema defined and indices created, we can now perform various operations, such as creating new records, querying records, and updating records:</p> <pre><code># Create a new user\nnew_user = await User(username='chirpy_user', display_name='Chirpy User', bio='I love chirping!').save()\n\n# Create a new chirp\nnew_chirp = await Chirp(author=new_user, content='Hello, Chirper!', likes=0, timestamp=int(time.time())).save()\n\n# Query chirps by author\nchirps_by_author = await Chirp.where_eq(author=new_user).all()\n\n# Update a chirp\nnew_chirp.likes += 1\nupdated_chirp = await new_chirp.save()\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>For detailed documentation, including advanced features such as revision history, forgetting data, and pagination, refer to the docs folder in the repository or visit the official documentation website.</p>"},{"location":"#building-the-docs","title":"Building the Docs","text":"<p>To build the documentation, you will need to install the dependencies listed in the requirements.txt and docs-requirements.txt. Then, run the following command:</p> <pre><code>mkdocs build\n</code></pre> <p>You can serve the documentation locally by running the following command:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions to AARS are welcome! If you have found a bug, want to suggest an improvement, or have a question, feel free to open an issue on the GitHub repository.</p>"},{"location":"#license","title":"License","text":"<p>AARS is released under the MIT License.</p>"},{"location":"FastAPI_Cookbook/","title":"FastAPI Cookbook","text":"<p>This cookbook will show you how to build and test an advanced FastAPI app using the full suite of AARS features:</p> <ul> <li>Indexing for efficient querying</li> <li>Built-in pagination for large result sets</li> <li>Support for caching</li> <li>Listening for new messages on Aleph</li> </ul>"},{"location":"FastAPI_Cookbook/#basic-setup","title":"Basic setup","text":"<p>Creating a FastAPI app with AARS is very simple. The following code snippet shows how to initialize AARS and add it to your FastAPI app. <pre><code>from fastapi import FastAPI\n\nfrom aleph.sdk.vm.app import AlephApp\n\nfrom aars import AARS, Record\n\nhttp_app = FastAPI()\n\n# Setup the Aleph app\napp = AlephApp(http_app=http_app)\n\n# Initialize AARS\naars = AARS(\n    channel=\"MY_CHANNEL\",\n)\n</code></pre> Your app is now ready to use AARS. The next step is to define your data schema.</p>"},{"location":"FastAPI_Cookbook/#interlude-caching-aleph-messages","title":"Interlude: Caching Aleph messages","text":"<p>You can use a cache to speed up subsequent fetches of Aleph messages: <pre><code>from aleph.sdk.vm.cache import VmCache, TestVmCache\nfrom os import getenv\nTEST_CACHE = getenv(\"TEST_CACHE\")\nif TEST_CACHE is not None and TEST_CACHE.lower() == \"true\":\n    cache = TestVmCache()\nelse:\n    cache = VmCache()\n\naars = AARS(\n    channel=\"MY_CHANNEL\",\n    cache=cache\n)\n</code></pre> In this example, setting the <code>TEST_CACHE</code> environment variable to <code>true</code> will use a cache that you can easily run locally with Uvicorn: <pre><code>export TEST_CACHE=true\npython -m uvicorn aars.test_cache:app --reload\n</code></pre></p> <p>Caches work well with Aleph messages, as they are immutable.</p> <p>An exception to this are records that have been forgotten. AARS will handle cache invalidation automatically, if you use the <code>forget</code> method to forget a record. But you should be aware that forgotten messages differ from the original message and other actors thay may forget your message can invalidate your cache without AARS noticing.</p> <p>Use a cache whenever possible</p>"},{"location":"FastAPI_Cookbook/#defining-a-data-schema","title":"Defining a data schema","text":"<p>Now that we have AARS initialized, we can create a record. <pre><code>from typing import Optional\n\nfrom aars import Index\n\nclass User(Record):\n    username: str\n    display_name: str\n    bio: Optional[str]\n\nIndex(User, 'username')\n</code></pre> This code snippet creates a User record with three fields: <code>username</code>, <code>display_name</code>, and <code>bio</code>. The <code>Index</code> class creates an index on the <code>username</code> field. This is required for efficient querying.</p>"},{"location":"FastAPI_Cookbook/#syncing-indices","title":"Syncing indices","text":"<p>We call <code>AARS.sync_indices()</code> to sync the indices with the Aleph VM. This is necessary if you have previously created records through AARS and want to query them using the indices.</p> <p>The correct way to handle syncing indices is to call <code>AARS.sync_indices()</code> on the ASGI startup sequence. This is the sequence of events that FastAPI runs when it starts up. You can read more about it here. <pre><code>import asyncio\n\n# IMPORTANT: app should be the AlephApp instance\n@app.on_event(\"startup\")\nasync def startup():\n    await asyncio.wait_for(AARS.sync_indices(), timeout=None)\n</code></pre> Note that we are using <code>asyncio.wait_for</code> to wait for the indices to sync, as we can set the timeout to <code>None</code> for the possibly lengthy operation.</p> <p>Warning</p> <p>Calling <code>AARS.sync_indices()</code> scales linearly with the number of records in the VM. This means that if you have 1000 records, it will take roughly <code>1000 / 50 = 20</code> API calls to sync the indices. This is why it is recommended to call <code>AARS.sync_indices()</code> only once, after you have created all of your records and indices. AARS will automatically add records to the indices as they are created.</p>"},{"location":"FastAPI_Cookbook/#creating-and-querying-records-with-fastapi","title":"Creating and querying Records with FastAPI","text":"<p>Now that we have a record, we can create a FastAPI endpoint to create and query records.</p>"},{"location":"FastAPI_Cookbook/#creating-a-record","title":"Creating a Record","text":"<p><pre><code>@app.post(\"/users\")\nasync def create_user(\n    username: str,\n    display_name: str,\n    bio: Optional[str] = None,\n) -&gt; User:\n    user = User(\n        username=username,\n        display_name=display_name,\n        bio=bio,\n    )\n    return await user.save()\n</code></pre> This endpoint will create a new user record and return it.</p>"},{"location":"FastAPI_Cookbook/#fetching-records","title":"Fetching Records","text":"<p><pre><code>from typing import List\n@app.get(\"/users\")\nasync def get_users(\n    page: int = 1,\n    page_size: int = 20,\n) -&gt; List[User]:\n    return await User.fetch_objects().page(page=page, page_size=page_size)\n</code></pre> This endpoint will return a list of users, paginated by 20 users per page.</p>"},{"location":"FastAPI_Cookbook/#using-an-index-to-query-records","title":"Using an Index to query Records","text":"<p><pre><code>@app.get(\"/users/{username}\")\nasync def get_user(\n    username: str,\n) -&gt; User:\n    return await User.fetch_objects().where_eq(username=username).first()\n</code></pre> This endpoint will return a single user, given their username.</p>"},{"location":"FastAPI_Cookbook/#listening-to-aleph-messages","title":"Listening to Aleph Messages","text":"<p>TODO</p> <p>This section is not yet complete.</p>"},{"location":"Code_Reference/Exceptions/","title":"Exceptions","text":"<p>Types of exceptions that can be raised when using the AARS library. All exceptions are subclasses of AlephError.</p>"},{"location":"Code_Reference/Exceptions/#aars.exceptions.AlephError","title":"<code>AlephError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for exceptions in this module.</p>"},{"location":"Code_Reference/Exceptions/#aars.exceptions.AlephPermissionError","title":"<code>AlephPermissionError(user_address: str, item_hash: str, item_owner: str, message = 'User {0} is not authorized to modify {1} by user {2}')</code>","text":"<p>         Bases: <code>AlephError</code></p> <p>Exception raised when a user is not authorized to perform an action on an item.</p> Source code in <code>aars/exceptions.py</code> <pre><code>def __init__(self,\n             user_address: str,\n             item_hash: str,\n             item_owner: str,\n             message=\"User {0} is not authorized to modify {1} by user {2}\"):\n    self.user_address = user_address\n    self.item_hash = item_hash\n    self.item_owner = item_owner\n    self.message = message.format(self.user_address, self.item_hash, self.item_owner)\n    super().__init__(self.message)\n</code></pre>"},{"location":"Code_Reference/Exceptions/#aars.exceptions.AlreadyForgottenError","title":"<code>AlreadyForgottenError(content, message = \"Object '{0}' has already been forgotten. It is recommended to delete the called object locally.\")</code>","text":"<p>         Bases: <code>AlephError</code></p> <p>Exception raised when a user tries to forget an item that has already been forgotten.</p> Source code in <code>aars/exceptions.py</code> <pre><code>def __init__(\n    self,\n    content,\n    message=\"Object '{0}' has already been forgotten. It is recommended to delete the \"\n    \"called object locally.\",\n):\n    self.item_hash = content.id_hash\n    self.message = f\"{message.format(self.item_hash)}\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"Code_Reference/Exceptions/#aars.exceptions.AlreadyUsedError","title":"<code>AlreadyUsedError(message = 'PageableResponse has already been iterated over. It is recommended to to store the result of all() or page() or to create a new query.')</code>","text":"<p>         Bases: <code>AlephError</code></p> <p>Exception raised when a PageableResponse has already been used.</p> Source code in <code>aars/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message=\"PageableResponse has already been iterated over. It is recommended to \"\n    \"to store the result of all() or page() or to create a new query.\",\n):\n    self.message = message\n    super().__init__(self.message)\n</code></pre>"},{"location":"Code_Reference/Exceptions/#aars.exceptions.InvalidMessageTypeError","title":"<code>InvalidMessageTypeError(received, expected, message = \"Expected message type '{0}' but actually received '{1}'\")</code>","text":"<p>         Bases: <code>AlephError</code></p> <p>Exception raised when program received a different message type than expected.</p> Source code in <code>aars/exceptions.py</code> <pre><code>def __init__(\n    self,\n    received,\n    expected,\n    message=\"Expected message type '{0}' but actually received '{1}'\",\n):\n    self.received = received\n    self.expected = expected\n    self.message = f\"{message.format(self.expected, self.received)}\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"Code_Reference/Exceptions/#aars.exceptions.NotStoredError","title":"<code>NotStoredError(record, message = \"Record '{0}'\\nis not stored on Aleph. It is required to store the record with .save() before calling this method.\")</code>","text":"<p>         Bases: <code>AlephError</code></p> <p>Exception raised when a requested object is not stored on Aleph and has no <code>item_hash</code>.</p> Source code in <code>aars/exceptions.py</code> <pre><code>def __init__(\n    self,\n    record,\n    message=\"Record '{0}'\\nis not stored on Aleph. It is required to store the \"\n    \"record with .save() before calling this method.\",\n):\n    self.type = record.content\n    self.message = f\"{message.format(self.type)}\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"Code_Reference/Exceptions/#aars.exceptions.PostTypeIsNoClassError","title":"<code>PostTypeIsNoClassError(content, message = \"Received post_type '{0}' from channel '{1}' does not currently exist as a class.\")</code>","text":"<p>         Bases: <code>AlephError</code></p> <p>Exception raised when a received post_type is not resolvable to any python class in current runtime.</p> Source code in <code>aars/exceptions.py</code> <pre><code>def __init__(\n    self,\n    content,\n    message=\"Received post_type '{0}' from channel '{1}' does not currently exist as a \"\n    \"class.\",\n):\n    self.post_type = content[\"type\"]\n    self.content = content[\"content\"]\n    self.channel = content[\"channel\"]\n    self.message = f\"\"\"{message.format(self.post_type, self.channel)}\\n\n    Response of {self.post_type} provides the following fields:\\n\n{[key for key in self.content.keys()]}\"\"\"\n    super().__init__(self.message)\n</code></pre>"},{"location":"Code_Reference/utils/","title":"Utils","text":"<p>This module contains utility functions and classes for the AARS library. Most notably it contains the IndexQuery class, which prepares a query for records using an Index.</p> <p>Also, it contains the PageableResponse and PageableRequest classes, which allow for easy pagination of queries and efficient retrieval of large amounts of data in the asynchronous environment of AARS.</p>"},{"location":"Code_Reference/utils/#aars.utils.EmptyAsyncIterator","title":"<code>EmptyAsyncIterator</code>","text":"<p>         Bases: <code>AsyncIterator[T]</code></p> <p>An async iterator that can be returned when there are no results.</p>"},{"location":"Code_Reference/utils/#aars.utils.IndexQuery","title":"<code>IndexQuery(record_type: Type[T], **kwargs)</code>","text":"<p>         Bases: <code>OrderedDict</code>, <code>Generic[T]</code></p> <p>A query for a specific index. The keys are the index keys, and the values are the values to query for. It is an ordered dict in which the order is alphabetically determined by the keys, so that the same query will always have the same string representation. This is used to determine the index name.</p> <p>Create a new IndexQuery.</p> <p>Parameters:</p> Name Type Description Default <code>record_type</code> <code>Type[T]</code> <p>The type of record that this query is for.</p> required <code>**kwargs</code> <p>The keys and values to query for.</p> <code>{}</code> Source code in <code>aars/utils.py</code> <pre><code>def __init__(self, record_type: Type[T], **kwargs):\n\"\"\"\n    Create a new IndexQuery.\n    Args:\n        record_type: The type of record that this query is for.\n        **kwargs: The keys and values to query for.\n    \"\"\"\n    super().__init__(\n        {item[0]: item[1] for item in sorted(kwargs.items()) if item[1] is not None}\n    )\n    self.record_type = record_type\n</code></pre>"},{"location":"Code_Reference/utils/#aars.utils.IndexQuery.get_index_name","title":"<code>get_index_name() -&gt; str</code>","text":"<p>Get the name of the index that this query would use.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the index to query.</p> Source code in <code>aars/utils.py</code> <pre><code>def get_index_name(self) -&gt; str:\n\"\"\"\n    Get the name of the index that this query would use.\n    Returns:\n        The name of the index to query.\n    \"\"\"\n    return self.record_type.__name__ + \".\" + \".\".join(self.keys())\n</code></pre>"},{"location":"Code_Reference/utils/#aars.utils.IndexQuery.get_subquery","title":"<code>get_subquery(keys: List[str]) -&gt; IndexQuery</code>","text":"<p>Get a subquery of this query, containing only the specified keys.</p> Example <pre><code>query = IndexQuery(record_type=MyRecord, a=1, b=2, c=3)\nsubquery = query.get_subquery([\"a\", \"c\"])\nassert subquery == IndexQuery(record_type=MyRecord, a=1, c=3)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[str]</code> <p>The keys to include in the subquery.</p> required <p>Returns:</p> Type Description <code>IndexQuery</code> <p>The subquery.</p> Source code in <code>aars/utils.py</code> <pre><code>def get_subquery(self, keys: List[str]) -&gt; \"IndexQuery\":\n\"\"\"\n    Get a subquery of this query, containing only the specified keys.\n    Example:\n        ```python\n        query = IndexQuery(record_type=MyRecord, a=1, b=2, c=3)\n        subquery = query.get_subquery([\"a\", \"c\"])\n        assert subquery == IndexQuery(record_type=MyRecord, a=1, c=3)\n        ```\n    Args:\n        keys: The keys to include in the subquery.\n    Returns:\n        The subquery.\n    \"\"\"\n    return IndexQuery(\n        self.record_type, **{key: arg for key, arg in self.items() if key in keys}\n    )\n</code></pre>"},{"location":"Code_Reference/utils/#aars.utils.PageableRequest","title":"<code>PageableRequest(func: Callable[..., AsyncIterator[T]], *args, **kwargs)</code>","text":"<p>         Bases: <code>AsyncIterator[T]</code>, <code>Generic[T]</code></p> <p>A wrapper around a request that returns a PageableResponse. Useful if performance improvements can be obtained by passing page and page_size parameters to the request. Can be treated like PageableResponse.</p> <p>Create a new PageableRequest. The request will be triggered when the first record is requested.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., AsyncIterator[T]]</code> <p>The function to call to get the record generator.</p> required <code>*args</code> <p>The arguments to pass to the function.</p> <code>()</code> <code>**kwargs</code> <p>The keyword arguments to pass to the function.</p> <code>{}</code> Source code in <code>aars/utils.py</code> <pre><code>def __init__(self, func: Callable[..., AsyncIterator[T]], *args, **kwargs):\n\"\"\"\n    Create a new PageableRequest. The request will be triggered when the first record is requested.\n    Args:\n        func: The function to call to get the record generator.\n        *args: The arguments to pass to the function.\n        **kwargs: The keyword arguments to pass to the function.\n    \"\"\"\n    self.func = func\n    self.args = args\n    self.kwargs = kwargs\n</code></pre>"},{"location":"Code_Reference/utils/#aars.utils.PageableRequest.response","title":"<code>response</code>  <code>property</code>","text":"<p>The PageableResponse of this request.</p>"},{"location":"Code_Reference/utils/#aars.utils.PageableRequest.all","title":"<code>all() -&gt; List[T]</code>  <code>async</code>","text":"<p>Trigger the request and return all records.</p> <p>Returns:</p> Type Description <code>List[T]</code> <p>A list of all records.</p> Source code in <code>aars/utils.py</code> <pre><code>async def all(self) -&gt; List[T]:\n\"\"\"\n    Trigger the request and return all records.\n    Returns:\n        A list of all records.\n    \"\"\"\n    return await self.response.all()\n</code></pre>"},{"location":"Code_Reference/utils/#aars.utils.PageableRequest.first","title":"<code>first() -&gt; Optional[T]</code>  <code>async</code>","text":"<p>Trigger the request and return the first record.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The first record, or None if there are no records.</p> Source code in <code>aars/utils.py</code> <pre><code>async def first(self) -&gt; Optional[T]:\n\"\"\"\n    Trigger the request and return the first record.\n    Returns:\n        The first record, or None if there are no records.\n    \"\"\"\n    self._response = PageableResponse(\n        self.func(*self.args, **self.kwargs, page=1, page_size=1)\n    )\n    return await self.response.first()\n</code></pre>"},{"location":"Code_Reference/utils/#aars.utils.PageableRequest.page","title":"<code>page(page: int, page_size: int) -&gt; List[T]</code>  <code>async</code>","text":"<p>Trigger the request and return a page of records.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>The page number to fetch.</p> required <code>page_size</code> <code>int</code> <p>The number of records per page.</p> required <p>Returns:</p> Type Description <code>List[T]</code> <p>A list of records on the specified page.</p> Source code in <code>aars/utils.py</code> <pre><code>async def page(self, page: int, page_size: int) -&gt; List[T]:\n\"\"\"\n    Trigger the request and return a page of records.\n    Args:\n        page: The page number to fetch.\n        page_size: The number of records per page.\n    Returns:\n        A list of records on the specified page.\n    \"\"\"\n    self._response = PageableResponse(\n        self.func(*self.args, **self.kwargs, page=page, page_size=page_size)\n    )\n    return await self.response.all()\n</code></pre>"},{"location":"Code_Reference/utils/#aars.utils.PageableResponse","title":"<code>PageableResponse(record_generator: AsyncIterator[T])</code>","text":"<p>         Bases: <code>AsyncIterator[T]</code>, <code>Generic[T]</code></p> <p>A wrapper around an AsyncIterator that allows for easy pagination and iteration, while also preventing multiple iterations. This is mainly used for nicer syntax when not using the async generator syntax.</p> Iterate over all records <pre><code>async for record in PageableResponse(record_generator):\n    print(record)\n</code></pre> Consuming the generator <p>Calling any of the methods will consume the generator, so it is not possible to iterate over the records after calling any of the methods.</p> Iteration vs. Fetching all records at once <p>If you plan to stop iterating over the records after a certain point, it is more efficient to use the <code>async for</code> syntax, as it will consume less calls to the Aleph Message API. If you want to get all records, AARS will automatically use the most efficient amount of API calls to do so.</p> Source code in <code>aars/utils.py</code> <pre><code>def __init__(self, record_generator: AsyncIterator[T]):\n    self.record_generator = record_generator\n</code></pre>"},{"location":"Code_Reference/utils/#aars.utils.PageableResponse.all","title":"<code>all() -&gt; List[T]</code>  <code>async</code>","text":"<p>Fetch all records of this response.</p> Fetch all records <pre><code>records = await PageableResponse(record_generator).all()\n</code></pre> <p>Returns:</p> Type Description <code>List[T]</code> <p>A list of all records.</p> Source code in <code>aars/utils.py</code> <pre><code>async def all(self) -&gt; List[T]:\n\"\"\"\n    Fetch all records of this response.\n\n    Example: Fetch all records\n        ```python\n        records = await PageableResponse(record_generator).all()\n        ```\n    Returns:\n        A list of all records.\n    \"\"\"\n    if self.used:\n        raise AlreadyUsedError()\n    self.used = True\n    return await async_iterator_to_list(self.record_generator)\n</code></pre>"},{"location":"Code_Reference/utils/#aars.utils.PageableResponse.first","title":"<code>first() -&gt; Optional[T]</code>  <code>async</code>","text":"<p>Fetch the first record, which is usually the most recent record.</p> Fetch the first record <pre><code>record = await PageableResponse(record_generator).first()\n</code></pre> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The first record, or None if there are no records.</p> Source code in <code>aars/utils.py</code> <pre><code>async def first(self) -&gt; Optional[T]:\n\"\"\"\n    Fetch the first record, which is usually the most recent record.\n\n    Example: Fetch the first record\n        ```python\n        record = await PageableResponse(record_generator).first()\n        ```\n    Returns:\n        The first record, or None if there are no records.\n    \"\"\"\n    if self.used:\n        raise AlreadyUsedError()\n    self.used = True\n    try:\n        return await self.record_generator.__anext__()\n    except StopAsyncIteration:\n        return None\n</code></pre>"},{"location":"Code_Reference/utils/#aars.utils.PageableResponse.page","title":"<code>page(page: int, page_size: int) -&gt; List[T]</code>  <code>async</code>","text":"<p>Fetch a page of records.</p> Fetch a page of records <pre><code>records = await PageableResponse(record_generator).page(2, 10)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>The page number to fetch.</p> required <code>page_size</code> <code>int</code> <p>The number of records per page.</p> required <p>Returns:</p> Type Description <code>List[T]</code> <p>A list of records on the specified page.</p> Source code in <code>aars/utils.py</code> <pre><code>async def page(self, page: int, page_size: int) -&gt; List[T]:\n\"\"\"\n    Fetch a page of records.\n\n    Example: Fetch a page of records\n        ```python\n        records = await PageableResponse(record_generator).page(2, 10)\n        ```\n    Args:\n        page: The page number to fetch.\n        page_size: The number of records per page.\n    Returns:\n        A list of records on the specified page.\n    \"\"\"\n    if self.used:\n        raise AlreadyUsedError()\n    self.used = True\n    return await async_iterator_to_list(\n        self.record_generator, (page - 1) * page_size, page_size\n    )\n</code></pre>"},{"location":"Code_Reference/utils/#aars.utils.async_iterator_to_list","title":"<code>async_iterator_to_list(iterator: AsyncIterator[T], skip: int = 0, count: Optional[int] = None) -&gt; List[T]</code>  <code>async</code>","text":"<p>Return a list from an async iterator.</p> <p>Parameters:</p> Name Type Description Default <code>iterator</code> <code>AsyncIterator[T]</code> <p>The async iterator to convert to a list.</p> required <code>skip</code> <code>int</code> <p>The number of items to skip.</p> <code>0</code> <code>count</code> <code>Optional[int]</code> <p>The maximum number of items to return.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[T]</code> <p>A list of items.</p> Source code in <code>aars/utils.py</code> <pre><code>async def async_iterator_to_list(\n    iterator: AsyncIterator[T], skip: int = 0, count: Optional[int] = None\n) -&gt; List[T]:\n\"\"\"\n    Return a list from an async iterator.\n    Args:\n        iterator: The async iterator to convert to a list.\n        skip: The number of items to skip.\n        count: The maximum number of items to return.\n    Returns:\n        A list of items.\n    \"\"\"\n    if count is None and skip == 0:\n        return [item async for item in iterator]\n    else:\n        items = []\n        async for item in iterator:\n            if skip &gt; 0:\n                skip -= 1\n                continue\n\n            items.append(item)\n            if len(items) == count:\n                break\n        return items\n</code></pre>"},{"location":"Code_Reference/utils/#aars.utils.possible_index_names","title":"<code>possible_index_names(seq)</code>","text":"<p>Return all possible index names for a sequence of properties.</p> Example <pre><code>list(possible_index_names(['A', 'B', 'C'])) == [['A'], ['A.B'], ['A.B.C'], ['B'], ['B.C'], ['C']]\n</code></pre> Source code in <code>aars/utils.py</code> <pre><code>def possible_index_names(seq):\n\"\"\"\n    Return all possible index names for a sequence of properties.\n\n    Example:\n        ```python\n        list(possible_index_names(['A', 'B', 'C'])) == [['A'], ['A.B'], ['A.B.C'], ['B'], ['B.C'], ['C']]\n        ```\n    \"\"\"\n    return map(\".\".join, subslices(seq))\n</code></pre>"},{"location":"Code_Reference/utils/#aars.utils.subslices","title":"<code>subslices(seq)</code>","text":"<p>Return all contiguous non-empty subslices of a sequence. Taken from more_itertools.</p> Example <pre><code>list(subslices([1, 2, 3])) == [[1], [1, 2], [1, 2, 3], [2], [2, 3], [3]]\n</code></pre> Source code in <code>aars/utils.py</code> <pre><code>def subslices(seq):\n\"\"\"\n    Return all contiguous non-empty subslices of a sequence.\n    Taken from more_itertools.\n\n    Example:\n        ```python\n        list(subslices([1, 2, 3])) == [[1], [1, 2], [1, 2, 3], [2], [2, 3], [3]]\n        ```\n    \"\"\"\n    #\n    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n    return map(operator.getitem, repeat(seq), slices)\n</code></pre>"},{"location":"Code_Reference/core/AARS/","title":"AARS","text":"<p>The AARS class is the main entry point for the Aleph Active Record SDK. It provides versatile methods to create, update, delete and query records.</p> <p>Initializes the SDK with an account and a channel.</p> <p>Parameters:</p> Name Type Description Default <code>account</code> <code>Optional[Account]</code> <p>Account with which to sign the messages. Defaults to the fallback account.</p> <code>None</code> <code>channel</code> <code>Optional[str]</code> <p>Channel to which to send the messages. Defaults to \u2018AARS_TEST\u2019.</p> <code>None</code> <code>api_url</code> <code>Optional[str]</code> <p>The API URL to use. Defaults to an official Aleph API host.</p> <code>None</code> <code>session</code> <code>Optional[AuthenticatedAlephClient]</code> <p>An aiohttp session to use. Defaults to a new session with the given account.</p> <code>None</code> <code>cache</code> <code>Optional[VmCache]</code> <p>An optional Aleph VM cache to cache messages.</p> <code>None</code> <code>retry_count</code> <code>Optional[int]</code> <p>The number of times to retry a failed request. Defaults to 3.</p> <code>None</code> Source code in <code>aars/core.py</code> <pre><code>def __init__(\n    self,\n    account: Optional[Account] = None,\n    channel: Optional[str] = None,\n    api_url: Optional[str] = None,\n    session: Optional[AuthenticatedAlephClient] = None,\n    cache: Optional[VmCache] = None,\n    retry_count: Optional[int] = None,\n):\n\"\"\"\n    Initializes the SDK with an account and a channel.\n    Args:\n        account: Account with which to sign the messages. Defaults to the fallback account.\n        channel: Channel to which to send the messages. Defaults to 'AARS_TEST'.\n        api_url: The API URL to use. Defaults to an official Aleph API host.\n        session: An aiohttp session to use. Defaults to a new session with the given account.\n        cache: An optional Aleph VM cache to cache messages.\n        retry_count: The number of times to retry a failed request. Defaults to 3.\n    \"\"\"\n    AARS.account = account if account else get_fallback_account()\n    AARS.channel = channel if channel else \"AARS_TEST\"\n    AARS.api_url = api_url if api_url else settings.API_HOST\n    AARS.session = (\n        session\n        if session\n        else AuthenticatedAlephClient(\n            account=AARS.account, api_server=settings.API_HOST\n        )\n    )\n    AARS.cache = cache\n    AARS.retry_count = retry_count if retry_count else 3\n</code></pre>"},{"location":"Code_Reference/core/AARS/#aars.core.AARS.fetch_exact","title":"<code>fetch_exact(record_type: Type[R], item_hash: str) -&gt; R</code>  <code>classmethod</code> <code>async</code>","text":"<p>Retrieves the revision of an object by its item_hash of the message. The content will be exactly the same as in the referenced message, so no amendments will be applied.</p> <p>Parameters:</p> Name Type Description Default <code>record_type</code> <code>Type[R]</code> <p>The type of the object to retrieve.</p> required <code>item_hash</code> <code>str</code> <p>item_hash of the message, whose content to fetch.</p> required <p>Returns:</p> Type Description <code>R</code> <p>The record in the state it was when the message was created.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\nasync def fetch_exact(cls, record_type: Type[R], item_hash: str) -&gt; R:\n\"\"\"Retrieves the revision of an object by its item_hash of the message. The content will be exactly the same\n    as in the referenced message, so no amendments will be applied.\n    Args:\n        record_type: The type of the object to retrieve.\n        item_hash: item_hash of the message, whose content to fetch.\n    Returns:\n        The record in the state it was when the message was created.\n    \"\"\"\n    if cls.cache:\n        cache_resp = await cls._fetch_records_from_cache(record_type, [item_hash])\n        if len(cache_resp) &gt; 0:\n            return cache_resp[0]\n    aleph_resp = await cls.session.get_messages(hashes=[item_hash])\n    if len(aleph_resp.messages) == 0:\n        raise ValueError(f\"Message with hash {item_hash} not found.\")\n    message: PostMessage = aleph_resp.messages[0]\n    return await record_type.from_post(message)\n</code></pre>"},{"location":"Code_Reference/core/AARS/#aars.core.AARS.fetch_records","title":"<code>fetch_records(record_type: Type[R], item_hashes: Optional[List[Union[str, ItemHash]]] = None, channel: Optional[str] = None, owner: Optional[str] = None, page_size: int = 50, page: int = 1) -&gt; AsyncIterator[R]</code>  <code>classmethod</code> <code>async</code>","text":"<p>Retrieves posts as objects by its aleph item_hash.</p> <p>Parameters:</p> Name Type Description Default <code>record_type</code> <code>Type[R]</code> <p>The type of the objects to retrieve.</p> required <code>item_hashes</code> <code>Optional[List[Union[str, ItemHash]]]</code> <p>Aleph item_hashes of the objects to fetch.</p> <code>None</code> <code>channel</code> <code>Optional[str]</code> <p>Channel in which to look for it.</p> <code>None</code> <code>owner</code> <code>Optional[str]</code> <p>Account that owns the object.</p> <code>None</code> <code>page_size</code> <code>int</code> <p>Number of items to fetch per page.</p> <code>50</code> <code>page</code> <code>int</code> <p>Page number to fetch, based on page_size.</p> <code>1</code> <p>Returns:</p> Type Description <code>AsyncIterator[R]</code> <p>An iterator over the found records.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\nasync def fetch_records(\n    cls,\n    record_type: Type[R],\n    item_hashes: Optional[List[Union[str, ItemHash]]] = None,\n    channel: Optional[str] = None,\n    owner: Optional[str] = None,\n    page_size: int = 50,\n    page: int = 1,\n) -&gt; AsyncIterator[R]:\n\"\"\"\n    Retrieves posts as objects by its aleph item_hash.\n    Args:\n        record_type: The type of the objects to retrieve.\n        item_hashes: Aleph item_hashes of the objects to fetch.\n        channel: Channel in which to look for it.\n        owner: Account that owns the object.\n        page_size: Number of items to fetch per page.\n        page: Page number to fetch, based on page_size.\n    Returns:\n        An iterator over the found records.\n    \"\"\"\n    assert issubclass(record_type, Record)\n    channels = None if channel is None else [channel]\n    owners = None if owner is None else [owner]\n    if item_hashes is None and channels is None and owners is None:\n        channels = [cls.channel]\n\n    if cls.cache and item_hashes is not None:\n        # TODO: Add some kind of caching for channels and owners or add recent item_hashes endpoint to the Aleph API\n        records = await cls._fetch_records_from_cache(record_type, item_hashes)\n        cached_ids = []\n        for r in records:\n            cached_ids.append(r.id_hash)\n            yield r\n        item_hashes = [h for h in item_hashes if h not in cached_ids]\n        if len(item_hashes) == 0:\n            return\n\n    async for record in cls._fetch_records_from_api(\n        record_type=record_type,\n        item_hashes=item_hashes,\n        channels=channels,\n        owners=owners,\n        page_size=page_size,\n        page=page,\n    ):\n        yield record\n</code></pre>"},{"location":"Code_Reference/core/AARS/#aars.core.AARS.fetch_revisions","title":"<code>fetch_revisions(record_type: Type[R], ref: str, channel: Optional[str] = None, owner: Optional[str] = None, page = 1) -&gt; AsyncIterator[ItemHash]</code>  <code>classmethod</code> <code>async</code>","text":"<p>Retrieves posts of revisions of an object by its item_hash.</p> <p>Parameters:</p> Name Type Description Default <code>record_type</code> <code>Type[R]</code> <p>The type of the objects to retrieve.</p> required <code>ref</code> <code>str</code> <p>item_hash of the object, whose revisions to fetch.</p> required <code>channel</code> <code>Optional[str]</code> <p>Channel in which to look for it.</p> <code>None</code> <code>owner</code> <code>Optional[str]</code> <p>Account that owns the object.</p> <code>None</code> <code>page</code> <p>Page number to fetch.</p> <code>1</code> <p>Returns:</p> Type Description <code>AsyncIterator[ItemHash]</code> <p>An iterator over the found records.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\nasync def fetch_revisions(\n    cls,\n    record_type: Type[R],\n    ref: str,\n    channel: Optional[str] = None,\n    owner: Optional[str] = None,\n    page=1,\n) -&gt; AsyncIterator[ItemHash]:\n\"\"\"Retrieves posts of revisions of an object by its item_hash.\n    Args:\n        record_type: The type of the objects to retrieve.\n        ref: item_hash of the object, whose revisions to fetch.\n        channel: Channel in which to look for it.\n        owner: Account that owns the object.\n        page: Page number to fetch.\n    Returns:\n        An iterator over the found records.\n    \"\"\"\n    owners = None if owner is None else [owner]\n    channels = None if channel is None else [channel]\n    if owners is None and channels is None:\n        channels = [cls.channel]\n\n    aleph_resp = None\n    retries = cls.retry_count\n    while aleph_resp is None:\n        try:\n            aleph_resp = await cls.session.get_messages(\n                channels=channels,\n                addresses=owners,\n                refs=[ref],\n                pagination=50,\n                page=page,\n            )\n        except ServerDisconnectedError:\n            retries -= 1\n            if retries == 0:\n                raise\n    for message in aleph_resp.messages:\n        yield message.item_hash\n\n    if page == 1:\n        # If there are more pages, fetch them\n        total_items = aleph_resp.pagination_total\n        per_page = aleph_resp.pagination_per_page\n        if total_items &gt; per_page:\n            for next_page in range(2, math.ceil(total_items / per_page) + 1):\n                async for item_hash in cls.fetch_revisions(\n                    record_type=record_type,\n                    ref=ref,\n                    channel=channel,\n                    owner=owner,\n                    page=next_page,\n                ):\n                    yield ItemHash(item_hash)\n</code></pre>"},{"location":"Code_Reference/core/AARS/#aars.core.AARS.forget_objects","title":"<code>forget_objects(objs: List[R], channel: Optional[str] = None)</code>  <code>classmethod</code> <code>async</code>","text":"<p>Forgets multiple objects from Aleph and local cache. All related revisions will be forgotten too.</p> <p>Parameters:</p> Name Type Description Default <code>objs</code> <code>List[R]</code> <p>The objects to forget.</p> required <code>channel</code> <code>Optional[str]</code> <p>The channel to delete the object from. If None, will use the configured default channel.</p> <code>None</code> Source code in <code>aars/core.py</code> <pre><code>@classmethod\nasync def forget_objects(\n    cls,\n    objs: List[R],\n    channel: Optional[str] = None,\n):\n\"\"\"\n    Forgets multiple objects from Aleph and local cache. All related revisions will be forgotten too.\n    Args:\n        objs: The objects to forget.\n        channel: The channel to delete the object from. If None, will use the configured default channel.\n    \"\"\"\n    if channel is None:\n        channel = cls.channel\n    hashes = []\n    for obj in objs:\n        if obj.id_hash is None:\n            raise ValueError(\"Cannot forget an object that has not been posted.\")\n        if obj.signer != cls.account.get_address():\n            raise AlephPermissionError(\n                obj.signer, obj.id_hash, cls.account.get_address()\n            )\n        hashes += [obj.id_hash] + obj.revision_hashes\n    forget_task = cls.session.forget(\n        hashes=hashes,\n        reason=None,\n        channel=channel,\n    )\n    if cls.cache:\n        await asyncio.gather(forget_task, *[cls.cache.delete(h) for h in hashes])\n    else:\n        await forget_task\n</code></pre>"},{"location":"Code_Reference/core/AARS/#aars.core.AARS.post_or_amend_object","title":"<code>post_or_amend_object(obj: R, channel: Optional[str] = None) -&gt; R</code>  <code>classmethod</code> <code>async</code>","text":"<p>Posts or amends an object to Aleph. If the object is already posted, it\u2019s list of revision hashes is updated and the object receives the latest revision number.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>R</code> <p>The object to post or amend.</p> required <code>channel</code> <code>Optional[str]</code> <p>The channel to post the object to. If None, will use the configured default channel.</p> <code>None</code> <p>Returns:</p> Type Description <code>R</code> <p>The object with the updated revision hashes and revision number.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\nasync def post_or_amend_object(cls, obj: R, channel: Optional[str] = None) -&gt; R:\n\"\"\"\n    Posts or amends an object to Aleph. If the object is already posted, it's list of revision hashes is updated and\n    the object receives the latest revision number.\n    Args:\n        obj: The object to post or amend.\n        channel: The channel to post the object to. If None, will use the configured default channel.\n    Returns:\n        The object with the updated revision hashes and revision number.\n    \"\"\"\n    if channel is None:\n        channel = cls.channel\n    assert isinstance(obj, Record)\n    post_type = type(obj).__name__ if obj.id_hash is None else \"amend\"\n    if obj.id_hash is not None and obj.signer is not None and obj.signer != cls.account.get_address():\n        raise AlephPermissionError(\n            cls.account.get_address(), obj.id_hash, obj.signer\n        )\n    message, status = await cls.session.create_post(\n        post_content=obj.content,\n        post_type=post_type,\n        channel=channel,\n        ref=obj.id_hash,\n    )\n    if obj.id_hash is None:\n        obj.id_hash = message.item_hash\n    obj.revision_hashes.append(message.item_hash)\n    obj.current_revision = len(obj.revision_hashes) - 1\n    obj.timestamp = message.time\n    obj.signer = message.sender\n    if cls.cache:\n        await cls.cache.set(message.item_hash, obj.json())\n    return obj\n</code></pre>"},{"location":"Code_Reference/core/AARS/#aars.core.AARS.sync_indices","title":"<code>sync_indices()</code>  <code>classmethod</code> <code>async</code>","text":"<p>Synchronizes all the indices created so far, by iteratively fetching all the messages from the channel, having post_types of the Record subclasses that have been declared so far.</p> <p>This can take quite some time on large databases.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\nasync def sync_indices(cls):\n\"\"\"\n    Synchronizes all the indices created so far, by iteratively fetching all the messages from the channel,\n    having post_types of the Record subclasses that have been declared so far.\n\n    !!! warning \"This can take quite some time on large databases.\"\n    \"\"\"\n    for record in Record.__subclasses__():\n        if record.get_indices():\n            await record.regenerate_indices()\n</code></pre>"},{"location":"Code_Reference/core/Index/","title":"Index","text":"<p>         Bases: <code>Record</code>, <code>Generic[R]</code></p> <p>An Index is a data structure that allows for fast lookup of records by their properties. It is used internally by the Record class and once created, is automatically updated when records are created or updated.</p> <p>It is not recommended using the Index class directly, but rather through the <code>where_eq</code> method of the <code>Record</code> class.</p> Example <p><pre><code>MyRecord.where_eq(foo='bar')\n</code></pre> If <code>MyRecord</code> has an index on the property <code>foo</code>, this will return all records of type <code>MyRecord</code> where <code>foo</code> is equal to <code>'bar'</code>.</p> <p>Creates a new index given a record_type and a single or multiple properties to index on.</p> Example <p><pre><code>Index(MyRecord, 'foo')\n</code></pre> Indexes all records of type MyRecord on the property \u2018foo\u2019.</p> <p>This will create an index named <code>'MyRecord.foo'</code>, which is stored in the <code>MyRecord</code> class.</p> <p>Parameters:</p> Name Type Description Default <code>record_type</code> <code>Type[R]</code> <p>The record_type to index.</p> required <code>on</code> <code>Union[str, List[str], Tuple[str]]</code> <p>The properties to index on. Can be a single property or a list/tuple of properties.</p> required Source code in <code>aars/core.py</code> <pre><code>def __init__(self, record_type: Type[R], on: Union[str, List[str], Tuple[str]]):\n\"\"\"\n    Creates a new index given a record_type and a single or multiple properties to index on.\n\n    Example:\n        ```python\n        Index(MyRecord, 'foo')\n        ```\n        Indexes all records of type MyRecord on the property 'foo'.\n\n    This will create an index named `'MyRecord.foo'`, which is stored in the `MyRecord` class.\n\n    Args:\n        record_type: The record_type to index.\n        on: The properties to index on. Can be a single property or a list/tuple of properties.\n    \"\"\"\n    if isinstance(on, str):\n        on = [on]\n    # check if all properties exist\n    for prop in on:\n        if prop not in record_type.__fields__:\n            raise ValueError(f\"Property {prop} does not exist on {record_type.__name__}\")\n    super(Index, self).__init__(record_type=record_type, index_on=sorted(on))\n    record_type.add_index(self)\n</code></pre>"},{"location":"Code_Reference/core/Index/#aars.core.Index.add_record","title":"<code>add_record(obj: R)</code>","text":"<p>Adds a record to the index.</p> Source code in <code>aars/core.py</code> <pre><code>def add_record(self, obj: R):\n\"\"\"Adds a record to the index.\"\"\"\n    assert issubclass(type(obj), Record)\n    assert obj.id_hash is not None\n    key = attrgetter(*self.index_on)(obj)\n    if isinstance(key, str):\n        key = (key,)\n    if isinstance(key, list):\n        key = tuple(key)\n    if key not in self.hashmap:\n        self.hashmap[key] = set()\n    self.hashmap[key].add(obj.id_hash)\n</code></pre>"},{"location":"Code_Reference/core/Index/#aars.core.Index.lookup","title":"<code>lookup(query: IndexQuery) -&gt; AsyncIterator[R]</code>","text":"<p>Fetches records with given values for the indexed properties.</p> Example <p><pre><code>index = Index(MyRecord, 'foo')\nindex_query = IndexQuery(MyRecord, **{'foo': 'bar'})\nindex.lookup(index_query)\n</code></pre> Returns all records of type <code>MyRecord</code> where <code>foo</code> is equal to <code>'bar'</code>. This is an anti-pattern, as the <code>IndexQuery</code> should be created by calling <code>MyRecord.where_eq(foo='bar')</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>IndexQuery</code> <p>The query to execute.</p> required <p>Returns:</p> Type Description <code>AsyncIterator[R]</code> <p>An async iterator over the records.</p> Source code in <code>aars/core.py</code> <pre><code>def lookup(self, query: IndexQuery) -&gt; AsyncIterator[R]:\n\"\"\"\n    Fetches records with given values for the indexed properties.\n\n    Example:\n        ```python\n        index = Index(MyRecord, 'foo')\n        index_query = IndexQuery(MyRecord, **{'foo': 'bar'})\n        index.lookup(index_query)\n        ```\n        Returns all records of type `MyRecord` where `foo` is equal to `'bar'`.\n        This is an anti-pattern, as the `IndexQuery` should be created by calling `MyRecord.where_eq(foo='bar')`\n        instead.\n\n    Args:\n        query: The query to execute.\n    Returns:\n        An async iterator over the records.\n    \"\"\"\n    assert query.record_type == self.record_type\n    id_hashes: Optional[Set[str]]\n    needs_filtering = False\n\n    subquery = query\n    if repr(self) != query.get_index_name():\n        subquery = query.get_subquery(self.index_on)\n        needs_filtering = True\n    id_hashes = self.hashmap.get(tuple(subquery.values()))\n\n    if id_hashes is None:\n        return EmptyAsyncIterator()\n\n    items = AARS.fetch_records(self.record_type, list(id_hashes))\n\n    if needs_filtering:\n        return self._filter_index_items(items, query)\n    return items\n</code></pre>"},{"location":"Code_Reference/core/Index/#aars.core.Index.regenerate","title":"<code>regenerate(items: List[R])</code>","text":"<p>Regenerates the index with given items.</p> Source code in <code>aars/core.py</code> <pre><code>def regenerate(self, items: List[R]):\n\"\"\"Regenerates the index with given items.\"\"\"\n    self.hashmap = {}\n    for item in items:\n        self.add_record(item)\n</code></pre>"},{"location":"Code_Reference/core/Index/#aars.core.Index.remove_record","title":"<code>remove_record(obj: R)</code>","text":"<p>Removes a record from the index, i.e. when it is forgotten.</p> Source code in <code>aars/core.py</code> <pre><code>def remove_record(self, obj: R):\n\"\"\"Removes a record from the index, i.e. when it is forgotten.\"\"\"\n    assert obj.id_hash is not None\n    key = attrgetter(*self.index_on)(obj)\n    if isinstance(key, str):\n        key = (key,)\n    if key in self.hashmap:\n        self.hashmap[key].remove(obj.id_hash)\n</code></pre>"},{"location":"Code_Reference/core/Record/","title":"Record","text":"<p>         Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>A basic record which is persisted on Aleph decentralized storage.</p> <p>Records can be updated: revision numbers begin at 0 (original upload) and increment for each <code>.save()</code> call.</p> <p>Previous revisions can be restored by calling <pre><code>await record.fetch_revision(rev_no=0)\n</code></pre> or <pre><code>await record.fetch_revision(rev_hash=\"abc123\")\n</code></pre></p> <p>They can also be forgotten: Aleph will ask the network to forget given item, in order to allow for GDPR-compliant applications.</p> <p>Records have an <code>indices</code> class attribute, which allows one to select an index and query it with a key.</p> <p>It uses <code>TypeVar(\"R\", bound=\"Record\")</code> to allow for type hinting of subclasses.</p>"},{"location":"Code_Reference/core/Record/#aars.core.Record.content","title":"<code>content: Dict[str, Any]</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary of the object\u2019s content, as it is to be stored on Aleph inside the <code>content</code> property of the POST message.</p>"},{"location":"Code_Reference/core/Record/#aars.core.Record.add_index","title":"<code>add_index(index: Index) -&gt; None</code>  <code>classmethod</code>","text":"<p>Adds an index to the class. This allows the index to be used for queries and will be automatically updated when records are created or updated.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Index</code> <p>The index to add.</p> required Source code in <code>aars/core.py</code> <pre><code>@classmethod\ndef add_index(cls: Type[R], index: \"Index\") -&gt; None:\n\"\"\"\n    Adds an index to the class. This allows the index to be used for queries and will be automatically updated\n    when records are created or updated.\n    Args:\n        index: The index to add.\n    \"\"\"\n    cls.__indices[repr(index)] = index\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.fetch","title":"<code>fetch(hashes: Union[Union[str, ItemHash], List[Union[str, ItemHash]]]) -&gt; PageableResponse[R]</code>  <code>classmethod</code>","text":"<p>Fetches one or more objects of given type by its/their item_hash[es].</p> <p>Parameters:</p> Name Type Description Default <code>hashes</code> <code>Union[Union[str, ItemHash], List[Union[str, ItemHash]]]</code> <p>The item_hash[es] of the objects to fetch.</p> required <p>Returns:</p> Type Description <code>PageableResponse[R]</code> <p>A pageable response object, which can be asynchronously iterated over.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\ndef fetch(\n    cls: Type[R], hashes: Union[Union[str, ItemHash], List[Union[str, ItemHash]]]\n) -&gt; PageableResponse[R]:\n\"\"\"\n    Fetches one or more objects of given type by its/their item_hash[es].\n    Args:\n        hashes: The item_hash[es] of the objects to fetch.\n    Returns:\n        A pageable response object, which can be asynchronously iterated over.\n    \"\"\"\n    if not isinstance(hashes, List):\n        hashes = [hashes]\n    items = AARS.fetch_records(cls, list(hashes))\n    return PageableResponse(items)\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.fetch_objects","title":"<code>fetch_objects() -&gt; PageableRequest[R]</code>  <code>classmethod</code>","text":"<p>Fetches all objects of given type.</p> <p>Returns:</p> Type Description <code>PageableRequest[R]</code> <p>A pageable request object, which can be asynchronously iterated over.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\ndef fetch_objects(cls: Type[R]) -&gt; PageableRequest[R]:\n\"\"\"\n    Fetches all objects of given type.\n\n    Returns:\n        A pageable request object, which can be asynchronously iterated over.\n    \"\"\"\n    return PageableRequest(AARS.fetch_records, record_type=cls)\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.fetch_revision","title":"<code>fetch_revision(rev_no: Optional[int] = None, rev_hash: Optional[str] = None) -&gt; R</code>  <code>async</code>","text":"<p>Fetches a Record\u2019s revision by its revision number (0 =&gt; original record) or revision hash.</p> <p>Parameters:</p> Name Type Description Default <code>rev_no</code> <code>Optional[int]</code> <p>The revision number of the revision to fetch. Negative numbers are allowed and count from the end.</p> <code>None</code> <code>rev_hash</code> <code>Optional[str]</code> <p>The hash of the revision to fetch.</p> <code>None</code> <p>Returns:</p> Type Description <code>R</code> <p>The object with the given revision.</p> Source code in <code>aars/core.py</code> <pre><code>async def fetch_revision(\n    self: R, rev_no: Optional[int] = None, rev_hash: Optional[str] = None\n) -&gt; R:\n\"\"\"\n    Fetches a Record's revision by its revision number (0 =&gt; original record) or revision hash.\n\n    Args:\n        rev_no: The revision number of the revision to fetch. Negative numbers are allowed and count from the end.\n        rev_hash: The hash of the revision to fetch.\n\n    Returns:\n        The object with the given revision.\n    \"\"\"\n    if self.id_hash is None:\n        raise NotStoredError(self)\n\n    if rev_no is not None:\n        if rev_no &lt; 0:\n            rev_no = len(self.revision_hashes) + rev_no\n        if self.current_revision == rev_no:\n            return self\n        elif rev_no &gt; len(self.revision_hashes):\n            raise IndexError(f\"No revision no. {rev_no} found for {self}\")\n        else:\n            self.current_revision = rev_no\n    elif rev_hash is not None:\n        rev_item_hash = ItemHash(rev_hash)\n        if self.current_revision and rev_hash == self.revision_hashes[self.current_revision]:\n            return self\n        try:\n            self.current_revision = self.revision_hashes.index(rev_item_hash)\n        except ValueError:\n            raise IndexError(f\"{rev_hash} is not a revision of {self}\")\n    else:\n        raise ValueError(\"Either rev or hash must be provided\")\n\n    resp = await AARS.fetch_exact(\n        type(self), self.revision_hashes[self.current_revision]\n    )\n    self.__dict__.update(resp.content)\n    self.timestamp = resp.timestamp\n    self.signer = resp.signer\n\n    return self\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.forget","title":"<code>forget() -&gt; R</code>  <code>async</code>","text":"<p>Orders Aleph to forget a specific object with all its revisions. Will remove the object from all indices. The content of all POST messages will be deleted, but the hashes and timestamps will remain.</p> <p>The forgotten object should be deleted afterwards, as it is useless now.</p> <p>Raises:</p> Type Description <code>NotStoredError</code> <p>If the object is not stored on Aleph.</p> <code>AlephPermissionError</code> <p>If the object is not owned by the current account.</p> <code>AlreadyForgottenError</code> <p>If the object was already forgotten.</p> Source code in <code>aars/core.py</code> <pre><code>async def forget(self: R) -&gt; R:\n\"\"\"\n    Orders Aleph to forget a specific object with all its revisions. Will remove the object from all indices.\n    The content of all POST messages will be deleted, but the hashes and timestamps will remain.\n    !!! note \"The forgotten object should be deleted afterwards, as it is useless now.\"\n    Raises:\n        NotStoredError: If the object is not stored on Aleph.\n        AlephPermissionError: If the object is not owned by the current account.\n        AlreadyForgottenError: If the object was already forgotten.\n    \"\"\"\n\n    if not self.forgotten:\n        if self.id_hash is None:\n            raise NotStoredError(self)\n        if self.signer != AARS.account.get_address():\n            raise AlephPermissionError(AARS.account.get_address(), self.id_hash, self.signer)\n        await AARS.forget_objects([self])\n        [index.remove_record(self) for index in self.get_indices()]\n        self.forgotten = True\n        return self\n    else:\n        raise AlreadyForgottenError(self)\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.forget_all","title":"<code>forget_all() -&gt; List[ItemHash]</code>  <code>classmethod</code> <code>async</code>","text":"<p>Forgets all Records of given type of the authorized user. If invoked on Record, will try to fetch all objects of the current channel and forget them.</p> <p>Returns:</p> Type Description <code>List[ItemHash]</code> <p>A list of all item hashes that were forgotten.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\nasync def forget_all(cls: Type[R]) -&gt; List[ItemHash]:\n\"\"\"\n    Forgets all Records of given type of the authorized user. If invoked on Record, will try to fetch all objects\n    of the current channel and forget them.\n    Returns:\n        A list of all item hashes that were forgotten.\n    \"\"\"\n    response = cls.fetch_objects()\n\n    item_hashes = []\n    record_batch = []\n    i = 0\n    async for record in response:\n        if record.signer != AARS.account.get_address():\n            continue\n        record_batch.append(record)\n        i += 1\n        if i % 50 == 0:\n            item_hashes.extend([record.id_hash for record in record_batch])\n            await AARS.forget_objects(record_batch)\n            record_batch = []\n    if record_batch:\n        item_hashes.extend([record.id_hash for record in record_batch])\n        await AARS.forget_objects(record_batch)\n\n    return item_hashes\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.from_dict","title":"<code>from_dict(post: Dict[str, Any]) -&gt; R</code>  <code>classmethod</code> <code>async</code>","text":"<p>Initializes a record object from its raw Aleph data.</p> <p>Parameters:</p> Name Type Description Default <code>post</code> <code>Dict[str, Any]</code> <p>The raw Aleph data to initialize from.</p> required <p>Returns:</p> Type Description <code>R</code> <p>The initialized object.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\nasync def from_dict(cls: Type[R], post: Dict[str, Any]) -&gt; R:\n\"\"\"\n    Initializes a record object from its raw Aleph data.\n    Args:\n        post: The raw Aleph data to initialize from.\n    Returns:\n        The initialized object.\n    \"\"\"\n    obj = cls(**post[\"content\"])\n    if post.get(\"ref\") is None:\n        obj.id_hash = ItemHash(post[\"item_hash\"])\n    else:\n        obj.id_hash = ItemHash(post[\"ref\"])\n    await obj.update_revision_hashes()\n    assert obj.id_hash is not None\n    obj.current_revision = obj.revision_hashes.index(obj.id_hash)\n    obj.timestamp = post[\"time\"]\n    obj.signer = post[\"sender\"]\n    return obj\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.from_post","title":"<code>from_post(post: PostMessage) -&gt; R</code>  <code>classmethod</code> <code>async</code>","text":"<p>Initializes a record object from its PostMessage.</p> <p>Parameters:</p> Name Type Description Default <code>post</code> <code>PostMessage</code> <p>The PostMessage to initialize from.</p> required <p>Returns:</p> Type Description <code>R</code> <p>The initialized object.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\nasync def from_post(cls: Type[R], post: PostMessage) -&gt; R:\n\"\"\"\n    Initializes a record object from its PostMessage.\n    Args:\n        post: The PostMessage to initialize from.\n    Returns:\n        The initialized object.\n    \"\"\"\n    obj: R = cls(**post.content.content)\n    if post.content.ref is None:\n        obj.id_hash = post.item_hash\n    else:\n        if isinstance(post.content.ref, str):\n            obj.id_hash = ItemHash(post.content.ref)\n        elif isinstance(post.content.ref, ChainRef):\n            obj.id_hash = post.content.ref.item_hash\n        else:\n            raise TypeError(f\"Unknown type of ref: {type(post.content.ref)}\")\n    await obj.update_revision_hashes()\n    assert obj.id_hash is not None\n    obj.current_revision = obj.revision_hashes.index(obj.id_hash)\n    obj.timestamp = post.time\n    obj.signer = post.sender\n    return obj\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.get_index","title":"<code>get_index(index_name: str) -&gt; Index[R]</code>  <code>classmethod</code>","text":"<p>Returns an index or any of its subindices by its name. The name is defined as <code>\"&lt;object_class&gt;.[&lt;object_properties&gt;.]\"</code> with the properties being sorted alphabetically. For example, <code>\"Book.author.title\"</code> is a valid index name, while <code>\"Book.title.author\"</code> is not.</p> <p>Parameters:</p> Name Type Description Default <code>index_name</code> <code>str</code> <p>The name of the index to fetch.</p> required <p>Returns:</p> Type Description <code>Index[R]</code> <p>The index instance or a subindex.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\ndef get_index(cls: Type[R], index_name: str) -&gt; \"Index[R]\":\n\"\"\"\n    Returns an index or any of its subindices by its name. The name is defined as\n    `\"&lt;object_class&gt;.[&lt;object_properties&gt;.]\"` with the properties being sorted alphabetically. For example,\n    `\"Book.author.title\"` is a valid index name, while `\"Book.title.author\"` is not.\n    Args:\n        index_name: The name of the index to fetch.\n    Returns:\n        The index instance or a subindex.\n    \"\"\"\n    index = cls.__indices.get(index_name)\n    if index is None:\n        key_subslices = subslices(list(index_name.split(\".\")[1:]))\n        # returns all plausible combinations of keys\n        key_subslices = sorted(key_subslices, key=lambda x: len(x), reverse=True)\n        for keys in key_subslices:\n            name = cls.__name__ + \".\" + \".\".join(keys)\n            if cls.__indices.get(name):\n                warnings.warn(f\"No index {index_name} found. Using {name} instead.\")\n                return cls.__indices[name]\n        raise IndexError(f\"No index or subindex for {index_name} found.\")\n    return index\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.get_indices","title":"<code>get_indices() -&gt; List[Index]</code>  <code>classmethod</code>","text":"<p>Returns all indices of a given Record subclass.</p> <p>Returns:</p> Type Description <code>List[Index]</code> <p>A list of existing indices.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\ndef get_indices(cls: Type[R]) -&gt; List[\"Index\"]:\n\"\"\"\n    Returns all indices of a given Record subclass.\n    Returns:\n        A list of existing indices.\n    \"\"\"\n    if cls == Record:\n        return list(cls.__indices.values())\n    return [index for index in cls.__indices.values() if index.record_type == cls]\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.is_indexed","title":"<code>is_indexed(id_hash: Union[ItemHash, str]) -&gt; bool</code>  <code>classmethod</code>","text":"<p>Checks if a given object is indexed.</p> <p>Parameters:</p> Name Type Description Default <code>id_hash</code> <code>Union[ItemHash, str]</code> <p>The hash of the object to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the object is indexed, False otherwise.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\ndef is_indexed(cls: Type[R], id_hash: Union[ItemHash, str]) -&gt; bool:\n\"\"\"\n    Checks if a given object is indexed.\n    Args:\n        id_hash: The hash of the object to check.\n    Returns:\n        True if the object is indexed, False otherwise.\n    \"\"\"\n    return id_hash in cls.__indexed_items\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.regenerate_indices","title":"<code>regenerate_indices() -&gt; List[R]</code>  <code>classmethod</code> <code>async</code>","text":"<p>Regenerates all indices of given Record subtype. If invoked on Record, will try to fetch all objects of the current channel and index them.</p> <p>This can take quite some time, depending on the amount of records to be fetched.</p> <p>Returns:</p> Type Description <code>List[R]</code> <p>A list of all records that were indexed.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\nasync def regenerate_indices(cls: Type[R]) -&gt; List[R]:\n\"\"\"\n    Regenerates all indices of given Record subtype.\n    If invoked on Record, will try to fetch all objects of the current channel and index them.\n\n    !!! warning \"This can take quite some time, depending on the amount of records to be fetched.\"\n\n    Returns:\n        A list of all records that were indexed.\n    \"\"\"\n    response = cls.fetch_objects()\n\n    records = []\n    async for record in response:\n        record._index()\n        records.append(record)\n    return records\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.remove_index","title":"<code>remove_index(index: Index) -&gt; None</code>  <code>classmethod</code>","text":"<p>Removes an index from the class. This stops the index from being used for queries or updates.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>Index</code> <p>The index to remove.</p> required Source code in <code>aars/core.py</code> <pre><code>@classmethod\ndef remove_index(cls: Type[R], index: \"Index\") -&gt; None:\n\"\"\"\n    Removes an index from the class. This stops the index from being used for queries or updates.\n    Args:\n        index: The index to remove.\n    \"\"\"\n    del cls.__indices[repr(index)]\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.save","title":"<code>save() -&gt; R</code>  <code>async</code>","text":"<p>Posts a new item to Aleph or amends it, if it was already posted. Will add new items to local indices. For indices to be persisted on Aleph, you need to call <code>save()</code> on the index itself or <code>cls.save_indices()</code>.</p> <p>Returns:</p> Type Description <code>R</code> <p>The updated object itself.</p> Source code in <code>aars/core.py</code> <pre><code>async def save(self: R) -&gt; R:\n\"\"\"\n    Posts a new item to Aleph or amends it, if it was already posted. Will add new items to local indices.\n    For indices to be persisted on Aleph, you need to call `save()` on the index itself or `cls.save_indices()`.\n    Returns:\n        The updated object itself.\n    \"\"\"\n    await AARS.post_or_amend_object(self)\n    if self.current_revision == 0:\n        self._index()\n    return self\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.save_indices","title":"<code>save_indices() -&gt; None</code>  <code>classmethod</code> <code>async</code>","text":"<p>Updates all indices of given Record subclass.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\nasync def save_indices(cls: Type[R]) -&gt; None:\n\"\"\"Updates all indices of given Record subclass.\"\"\"\n    tasks = [index.save() for index in cls.get_indices()]\n    await asyncio.gather(*tasks)\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.update_revision_hashes","title":"<code>update_revision_hashes() -&gt; R</code>  <code>async</code>","text":"<p>Updates the list of available revision hashes, in order to fetch these.</p> <p>Returns:</p> Type Description <code>R</code> <p>The object with the updated revision hashes.</p> Source code in <code>aars/core.py</code> <pre><code>async def update_revision_hashes(self: R) -&gt; R:\n\"\"\"\n    Updates the list of available revision hashes, in order to fetch these.\n\n    Returns:\n        The object with the updated revision hashes.\n    \"\"\"\n    assert self.id_hash is not None\n    self.revision_hashes = [self.id_hash] + await async_iterator_to_list(\n        AARS.fetch_revisions(type(self), ref=self.id_hash)\n    )\n    if self.current_revision is None:\n        # latest revision\n        self.current_revision = len(self.revision_hashes) - 1\n    return self\n</code></pre>"},{"location":"Code_Reference/core/Record/#aars.core.Record.where_eq","title":"<code>where_eq(**kwargs) -&gt; PageableResponse[R]</code>  <code>classmethod</code>","text":"<p>Queries an object by given properties through an index, in order to fetch applicable records. An index name is defined as <pre><code>\"Class.property1.property2\"\n</code></pre> and is initialized by creating an <code>Index</code> instance, targeting a BaseRecord class with a list of properties.</p> <pre><code>Index(MyRecord, ['property1', 'property2'])\n</code></pre> <p>This will create an index named \u2018MyRecord.property1.property2\u2019 which can be queried with:</p> <pre><code>MyRecord.where_eq(property1='value1', property2='value2')\n</code></pre> <p>If no index is defined for the given properties, an IndexError is raised.</p> <p>If only a part of the keys is indexed for the given query, a fallback index is used and locally filtered.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>The properties to query for.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PageableResponse[R]</code> <p>A pageable response object, which can be asynchronously iterated over.</p> Source code in <code>aars/core.py</code> <pre><code>@classmethod\ndef where_eq(cls: Type[R], **kwargs) -&gt; PageableResponse[R]:\n\"\"\"\n    Queries an object by given properties through an index, in order to fetch applicable records.\n    An index name is defined as\n    ```python\n    \"Class.property1.property2\"\n    ```\n    and is initialized by creating an `Index` instance, targeting a BaseRecord class with a list of properties.\n\n    ```python\n    Index(MyRecord, ['property1', 'property2'])\n    ```\n\n    This will create an index named 'MyRecord.property1.property2' which can be queried with:\n\n    ```python\n    MyRecord.where_eq(property1='value1', property2='value2')\n    ```\n\n    If no index is defined for the given properties, an IndexError is raised.\n\n    If only a part of the keys is indexed for the given query, a fallback index is used and locally filtered.\n\n    Args:\n        **kwargs: The properties to query for.\n    Returns:\n        A pageable response object, which can be asynchronously iterated over.\n    \"\"\"\n    query = IndexQuery(cls, **kwargs)\n    index = cls.get_index(query.get_index_name())\n    generator = index.lookup(query)\n    return PageableResponse(generator)\n</code></pre>"}]}